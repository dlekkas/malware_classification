import pickle
import yaml
import logging
import gzip
import sys
import scipy.stats
import numpy as np



OBJECT_DIR = 'obj/'
#LOGGING_FILE = 'log/features.log'
# Configure a custom logger for debugging purposes
#logging.basicConfig(
        #filename=LOGGING_FILE,
        #format='%(asctime)s %(levelname)-8s %(message)s',
        #level=logging.DEBUG,
        #datefmt='%d-%m-%Y %H:%M:%S')


def parse_bytes(file_name, addrlength=32):
    bytes_seq = bytearray()
    try:
        with gzip.open(file_name, 'rt') as fp:
            for line in fp.readlines():
                if not line.strip():
                    continue
                else:
                    mem_addr = int(addrlength/4)
                    line = line[mem_addr:].strip()
                    line = line.replace('?', '')  # ignore '?' characters
                    # store as bytearray for efficient memory management
                    bytes_seq = bytes_seq + bytearray.fromhex(line)
    except Exception as e:
        log_exception(e, sys.argv[0], file_name)
        bytes_seq = None
    return bytes_seq


def shannon_byte_entropy(byte_array, window_size):
    # fixed size numpy array for optimized performance
    byte_count = np.zeros((256,), dtype=int)
    for byte in byte_seq:
        byte_count[byte] += 1
    # calculate probability of occurence for each byte
    byte_probs = byte_count / len(byte_seq)
    entropy = scipy.stats.entropy(byte_probs)
    return entropy



def load_config(conf_file):
    with open(conf_file , 'r') as ymlfile:
        conf = yaml.load(ymlfile)
    return conf

# save an object as a pickle file
def save_obj(obj, name):
    with open(OBJECT_DIR + name + '.pkl', 'wb') as f:
        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)

# load an object saved as a pickle file
def load_obj(name):
    with open(OBJECT_DIR + name + '.pkl', 'rb') as f:
        return pickle.load(f)

# maintain a progress bar to show completion progress during feature extraction
def progress_bar(curr, total, full_progbar):
    frac = curr/total
    filled_progbar = round(frac*full_progbar)
    print('\r', '#'*filled_progbar + '-'*(full_progbar-filled_progbar), '[{:>7.2%}]'.format(frac), end='')
    if curr == total:
        print('\n')

def log_exception(e, progname, filename):
    asm_file = filename.split('/')[-1]
    logging.error(
            '[' + progname + '] File "'+ asm_file + '" raised ' + str(e.__class__) +
            '(' + str(e.__doc__) + ')')
