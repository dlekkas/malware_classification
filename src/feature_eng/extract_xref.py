from util import save_obj, log_exception, progress_bar

import pandas as pd
import numpy as np
import gzip
import re
import sys
import subprocess
import logging

DATASET_DIR = '/media/dimlek/TOSHIBA EXT/malware/'

### Unix GREP implementation 
### Feature extraction cannot be replicated by windows machines
def get_xrefs_info_unix(asm_file):
    proc = subprocess.run(['grep', 'CODE XREF', asm_file], stdout=subprocess.PIPE)
    if proc.returncode != 0:
        print('Error: Unix command "grep \'CODE XREF\' ' + asm_file + 
            ' exited with return code ' + str(proc.returncode))
        sys.exit(0)
    output = proc.stdout.decode('ISO-8859-1')
    xrefs_list = output.split('\n')
    return xrefs_list
    

def xref_initialization(): 
    # features for CODE XREFs
    codexref_features = ['code_xrefs', 'jump_refs', 'func_refs', 'code_up_refs', 'code_down_refs',
            'jump_refs_perc', 'func_refs_perc', 'code_up_refs_perc', 'code_down_refs_perc']
    # features for DATA XREFs
    dataxref_features = ['data_xrefs', 'write_refs', 'read_refs', 'taken_refs', 'data_up_refs', 
            'data_down_refs', 'write_refs_perc', 'read_refs_perc', 'taken_refs_perc',
            'data_up_refs_perc', 'data_down_refs_perc']
    xref_features = codexref_features + dataxref_features
    xref_dict = dict((k, []) for k in xref_features)
    return xref_dict


# Python regex implementation
def get_xref_features(asm_file, xref_dict):
    # encoding of .asm files produced by IDA Pro is ISO-8859-1
    with gzip.open(asm_file, 'rt', encoding='ISO-8859-1') as fp:
        # get index of file (any column can be used)
        idx = len(xref_dict['jump_refs'])
        for key in xref_dict.keys():
            xref_dict[key].append(0)
        # all code XREFs follow the pattern of the following regex
        for line in fp.readlines():
            # match_obj = re.search(r"\.text:[0-9A-F]{8}[\u0018\u0019][jp]", line)
            code_xref_match = re.search(r"[\u0018\u0019][jp]", line)
            if code_xref_match:
                xref_dict['code_xrefs'][idx] += 1
                match_res = code_xref_match.group(0)
                # based on IDA doc the character at the end of the address followed
                # by CODE XREF indicates what kind of execution transfer was it:
                # 'j' denotes jump and 'p' denotes function call
                jf_code = match_res[-1]
                if jf_code == 'j':
                    xref_dict['jump_refs'][idx] += 1
                elif jf_code == 'p':
                    xref_dict['func_refs'][idx] += 1
        
                # based on IDA doc the character before the execution transfer indicator
                # is an arrow poiting up if function is located upwards or an arrow
                # pointing down if function is located downwards.
                # '\x18' = up arrow and '\x19' = down arrow 
                updown_code = match_res[-2]
                if updown_code == '\x18':
                    xref_dict['code_up_refs'][idx] += 1
                elif updown_code == '\x19':
                    xref_dict['code_down_refs'][idx] += 1
            data_xref_match = re.search(r"[\u0018\u0019][owr]", line)
            if data_xref_match:
                xref_dict['data_xrefs'][idx] += 1
                match_res = data_xref_match.group(0)
                # based on IDA doc the character at the end of DATA XREF means:
                # 'w' denotes the location is being written to
                # 'r' denotes the location is being read from
                # 'o' denotes the location is being taken from it
                owr_code = match_res[1]
                if owr_code == 'r':
                    xref_dict['read_refs'][idx] += 1
                elif owr_code == 'w':
                    xref_dict['write_refs'][idx] += 1
                elif owr_code == 'o':
                    xref_dict['taken_refs'][idx] += 1
                # based on IDA doc the character before the execution transfer indicator
                # is an arrow poiting up if function is located upwards or an arrow
                # pointing down if function is located downwards.
                # '\x18' = up arrow and '\x19' = down arrow 
                updown_code = match_res[-2]
                if updown_code == '\x18':
                    xref_dict['data_up_refs'][idx] += 1
                elif updown_code == '\x19':
                    xref_dict['data_down_refs'][idx] += 1
    
    ## DATA XREF features ##
    if xref_dict['data_xrefs'][idx] != 0:
        xref_dict['read_refs_perc'][idx] = float(xref_dict['read_refs'][idx])/xref_dict['data_xrefs'][idx]
        xref_dict['write_refs_perc'][idx] = float(xref_dict['write_refs'][idx])/xref_dict['data_xrefs'][idx]
        xref_dict['taken_refs_perc'][idx]= float(xref_dict['taken_refs'][idx])/xref_dict['data_xrefs'][idx]
        xref_dict['data_up_refs_perc'][idx] = float(xref_dict['data_up_refs'][idx])/xref_dict['data_xrefs'][idx]
        xref_dict['data_down_refs_perc'][idx] = float(xref_dict['data_down_refs'][idx])/xref_dict['data_xrefs'][idx]

    ## CODE XREF features ##
    if xref_dict['code_xrefs'][idx] != 0:
        xref_dict['jump_refs_perc'][idx] = float(xref_dict['jump_refs'][idx])/xref_dict['code_xrefs'][idx]
        xref_dict['func_refs_perc'][idx] = float(xref_dict['func_refs'][idx])/xref_dict['code_xrefs'][idx]
        xref_dict['code_up_refs_perc'][idx] = float(xref_dict['code_up_refs'][idx])/xref_dict['code_xrefs'][idx]
        xref_dict['code_down_refs_perc'][idx] = float(xref_dict['code_down_refs'][idx])/xref_dict['code_xrefs'][idx]
    
    return xref_dict


def extract_xref(files_list):
    # total number of files to calculate completion percentage
    total_files = len(files_list)
    bad_files_names = []
    # Extract all features related to DATA and CODE XREF
    xref_dict = xref_initialization()
    for idx, file_name in enumerate(files_list):
        asm_file = DATASET_DIR + 'train/' + file_name + '.asm.gz'
        try:
            get_xref_features(asm_file, xref_dict)
        except Exception as e:
            # log corrupted files for future correction
            log_exception(e, sys.argv[0], asm_file)
            bad_files_idx.append(idx)
            bad_files_names.append(file_name)
        progress_bar(idx+1, total_files, 50)

    xref_pd = pd.DataFrame.from_dict(xref_dict)
    # store xref features to avoid recalculation
    save_obj(xref_pd, 'xref_features')
    '''
    save_obj(bad_files_names, 'bad_asm_files')
    # drop corrupted files (if any) from the training set
    if len(bad_files_names) > 0:
        # log the number of corrupted files
        logging.info('XREF Feature Extraction completed: ' + 
                str(len(bad_files_names)) + ' file(s) are corrupted.')
        # store the corrupted files names in 'bad_asm_files.txt'
        with open('bad_asm_files.txt', 'w') as bfp:
            for name in bad_files_names:
                bfp.write(name + '.asm')
    '''
    # save xref features dataframe to csv file to keep results (optional)
    xref_pd.to_csv('features/xref_features.csv', index=False)
    return xref_pd



train_labels = pd.read_csv('~/Documents/thesis/dataset/dataSample/trainLabels.csv')
files_list = train_labels['Id'].tolist()
extract_xref(files_list)



